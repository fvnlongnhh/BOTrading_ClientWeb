{"ast":null,"code":"/*!\n* chartjs-plugin-annotation v1.1.0\n* https://www.chartjs.org/chartjs-plugin-annotation/index\n * (c) 2021 chartjs-plugin-annotation Contributors\n * Released under the MIT License\n */\nimport { Element, defaults, Chart, Animations } from 'chart.js';\nimport { distanceBetweenPoints, callback, isFinite, addRoundedRectPath, toTRBLCorners, valueOrDefault, toFont, isArray, toRadians, isObject, clipArea, unclipArea } from 'chart.js/helpers';\nconst clickHooks = ['click', 'dblclick'];\nconst moveHooks = ['enter', 'leave'];\nconst hooks = clickHooks.concat(moveHooks);\n\nfunction updateListeners(chart, state, options) {\n  const annotations = state.annotations || [];\n  state.listened = false;\n  state.moveListened = false;\n  hooks.forEach(hook => {\n    if (typeof options[hook] === 'function') {\n      state.listened = true;\n      state.listeners[hook] = options[hook];\n    }\n  });\n  moveHooks.forEach(hook => {\n    if (typeof options[hook] === 'function') {\n      state.moveListened = true;\n    }\n  });\n\n  if (!state.listened || !state.moveListened) {\n    annotations.forEach(scope => {\n      if (!state.listened) {\n        clickHooks.forEach(hook => {\n          if (typeof scope[hook] === 'function') {\n            state.listened = true;\n          }\n        });\n      }\n\n      if (!state.moveListened) {\n        moveHooks.forEach(hook => {\n          if (typeof scope[hook] === 'function') {\n            state.listened = true;\n            state.moveListened = true;\n          }\n        });\n      }\n    });\n  }\n}\n\nfunction handleEvent(chart, state, event, options) {\n  if (state.listened) {\n    switch (event.type) {\n      case 'mousemove':\n      case 'mouseout':\n        handleMoveEvents(chart, state, event);\n        break;\n\n      case 'click':\n        handleClickEvents(chart, state, event, options);\n        break;\n    }\n  }\n}\n\nfunction handleMoveEvents(chart, state, event) {\n  if (!state.moveListened) {\n    return;\n  }\n\n  let element;\n\n  if (event.type === 'mousemove') {\n    element = getNearestItem(state.elements, event);\n  }\n\n  const previous = state.hovered;\n  state.hovered = element;\n  dispatchMoveEvents(chart, state, {\n    previous,\n    element\n  }, event);\n}\n\nfunction dispatchMoveEvents(chart, state, elements, event) {\n  const {\n    previous,\n    element\n  } = elements;\n\n  if (previous && previous !== element) {\n    dispatchEvent(chart, previous.options.leave || state.listeners.leave, previous, event);\n  }\n\n  if (element && element !== previous) {\n    dispatchEvent(chart, element.options.enter || state.listeners.enter, element, event);\n  }\n}\n\nfunction handleClickEvents(chart, state, event, options) {\n  const listeners = state.listeners;\n  const element = getNearestItem(state.elements, event);\n\n  if (element) {\n    const elOpts = element.options;\n    const dblclick = elOpts.dblclick || listeners.dblclick;\n    const click = elOpts.click || listeners.click;\n\n    if (element.clickTimeout) {\n      // 2nd click before timeout, so its a double click\n      clearTimeout(element.clickTimeout);\n      delete element.clickTimeout;\n      dispatchEvent(chart, dblclick, element, event);\n    } else if (dblclick) {\n      // if there is a dblclick handler, wait for dblClickSpeed ms before deciding its a click\n      element.clickTimeout = setTimeout(() => {\n        delete element.clickTimeout;\n        dispatchEvent(chart, click, element, event);\n      }, options.dblClickSpeed);\n    } else {\n      // no double click handler, just call the click handler directly\n      dispatchEvent(chart, click, element, event);\n    }\n  }\n}\n\nfunction dispatchEvent(chart, handler, element, event) {\n  callback(handler, [{\n    chart,\n    element\n  }, event]);\n}\n\nfunction getNearestItem(elements, position) {\n  let minDistance = Number.POSITIVE_INFINITY;\n  return elements.filter(element => element.options.display && element.inRange(position.x, position.y)).reduce((nearestItems, element) => {\n    const center = element.getCenterPoint();\n    const distance = distanceBetweenPoints(position, center);\n\n    if (distance < minDistance) {\n      nearestItems = [element];\n      minDistance = distance;\n    } else if (distance === minDistance) {\n      // Can have multiple items at the same distance in which case we sort by size\n      nearestItems.push(element);\n    }\n\n    return nearestItems;\n  }, []).sort((a, b) => a._index - b._index).slice(0, 1)[0]; // return only the top item\n}\n\nconst clamp = (x, from, to) => Math.min(to, Math.max(from, x));\n\nfunction clampAll(obj, from, to) {\n  for (const key of Object.keys(obj)) {\n    obj[key] = clamp(obj[key], from, to);\n  }\n\n  return obj;\n}\n\nfunction scaleValue(scale, value, fallback) {\n  value = typeof value === 'number' ? value : scale.parse(value);\n  return isFinite(value) ? scale.getPixelForValue(value) : fallback;\n}\n/**\n * Rotate a `point` relative to `center` point by `angle`\n * @param {{x: number, y: number}} point - the point to rotate\n * @param {{x: number, y: number}} center - center point for rotation\n * @param {number} angle - angle for rotation, in radians\n * @returns {{x: number, y: number}} rotated point\n */\n\n\nfunction rotated(point, center, angle) {\n  var cos = Math.cos(angle);\n  var sin = Math.sin(angle);\n  var cx = center.x;\n  var cy = center.y;\n  return {\n    x: cx + cos * (point.x - cx) - sin * (point.y - cy),\n    y: cy + sin * (point.x - cx) + cos * (point.y - cy)\n  };\n}\n\nclass BoxAnnotation extends Element {\n  inRange(mouseX, mouseY, useFinalPosition) {\n    const {\n      x,\n      y,\n      width,\n      height\n    } = this.getProps(['x', 'y', 'width', 'height'], useFinalPosition);\n    return mouseX >= x && mouseX <= x + width && mouseY >= y && mouseY <= y + height;\n  }\n\n  getCenterPoint(useFinalPosition) {\n    const {\n      x,\n      y,\n      width,\n      height\n    } = this.getProps(['x', 'y', 'width', 'height'], useFinalPosition);\n    return {\n      x: x + width / 2,\n      y: y + height / 2\n    };\n  }\n\n  draw(ctx) {\n    const {\n      x,\n      y,\n      width,\n      height,\n      options\n    } = this;\n    ctx.save();\n    ctx.lineWidth = options.borderWidth;\n    ctx.strokeStyle = options.borderColor;\n    ctx.fillStyle = options.backgroundColor;\n    ctx.setLineDash(options.borderDash);\n    ctx.lineDashOffset = options.borderDashOffset;\n    ctx.beginPath();\n    addRoundedRectPath(ctx, {\n      x,\n      y,\n      w: width,\n      h: height,\n      // TODO: v2 remove support for cornerRadius\n      radius: clampAll(toTRBLCorners(valueOrDefault(options.cornerRadius, options.borderRadius)), 0, Math.min(width, height) / 2)\n    });\n    ctx.closePath();\n    ctx.fill(); // If no border, don't draw it\n\n    if (options.borderWidth) {\n      ctx.stroke();\n    }\n\n    ctx.restore();\n  }\n\n  resolveElementProperties(chart, options) {\n    const xScale = chart.scales[options.xScaleID];\n    const yScale = chart.scales[options.yScaleID];\n    let {\n      top: y,\n      left: x,\n      bottom: y2,\n      right: x2\n    } = chart.chartArea;\n    let min, max;\n\n    if (!xScale && !yScale) {\n      return {\n        options: {}\n      };\n    }\n\n    if (xScale) {\n      min = scaleValue(xScale, options.xMin, x);\n      max = scaleValue(xScale, options.xMax, x2);\n      x = Math.min(min, max);\n      x2 = Math.max(min, max);\n    }\n\n    if (yScale) {\n      min = scaleValue(yScale, options.yMin, y2);\n      max = scaleValue(yScale, options.yMax, y);\n      y = Math.min(min, max);\n      y2 = Math.max(min, max);\n    }\n\n    return {\n      x,\n      y,\n      x2,\n      y2,\n      width: x2 - x,\n      height: y2 - y\n    };\n  }\n\n}\n\nBoxAnnotation.id = 'boxAnnotation';\nBoxAnnotation.defaults = {\n  display: true,\n  adjustScaleRange: true,\n  borderDash: [],\n  borderDashOffset: 0,\n  borderWidth: 1,\n  borderRadius: 0,\n  xScaleID: 'x',\n  xMin: undefined,\n  xMax: undefined,\n  yScaleID: 'y',\n  yMin: undefined,\n  yMax: undefined\n};\nBoxAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\nconst PI = Math.PI;\n\nconst pointInLine = (p1, p2, t) => ({\n  x: p1.x + t * (p2.x - p1.x),\n  y: p1.y + t * (p2.y - p1.y)\n});\n\nconst interpolateX = (y, p1, p2) => pointInLine(p1, p2, Math.abs((y - p1.y) / (p2.y - p1.y))).x;\n\nconst interpolateY = (x, p1, p2) => pointInLine(p1, p2, Math.abs((x - p1.x) / (p2.x - p1.x))).y;\n\nconst toPercent = s => typeof s === 'string' && s.endsWith('%') && parseFloat(s) / 100;\n\nfunction isLineInArea({\n  x,\n  y,\n  x2,\n  y2\n}, {\n  top,\n  right,\n  bottom,\n  left\n}) {\n  return !(x < left && x2 < left || x > right && x2 > right || y < top && y2 < top || y > bottom && y2 > bottom);\n}\n\nfunction limitPointToArea({\n  x,\n  y\n}, p2, {\n  top,\n  right,\n  bottom,\n  left\n}) {\n  if (x < left) {\n    y = interpolateY(left, {\n      x,\n      y\n    }, p2);\n    x = left;\n  }\n\n  if (x > right) {\n    y = interpolateY(right, {\n      x,\n      y\n    }, p2);\n    x = right;\n  }\n\n  if (y < top) {\n    x = interpolateX(top, {\n      x,\n      y\n    }, p2);\n    y = top;\n  }\n\n  if (y > bottom) {\n    x = interpolateX(bottom, {\n      x,\n      y\n    }, p2);\n    y = bottom;\n  }\n\n  return {\n    x,\n    y\n  };\n}\n\nfunction limitLineToArea(p1, p2, area) {\n  const {\n    x,\n    y\n  } = limitPointToArea(p1, p2, area);\n  const {\n    x: x2,\n    y: y2\n  } = limitPointToArea(p2, p1, area);\n  return {\n    x,\n    y,\n    x2,\n    y2,\n    width: Math.abs(x2 - x),\n    height: Math.abs(y2 - y)\n  };\n}\n\nclass LineAnnotation extends Element {\n  intersects(x, y, epsilon = 0.001) {\n    // Adapted from https://stackoverflow.com/a/6853926/25507\n    const sqr = v => v * v;\n\n    const {\n      x: x1,\n      y: y1,\n      x2,\n      y2\n    } = this;\n    const dx = x2 - x1;\n    const dy = y2 - y1;\n    const lenSq = sqr(dx) + sqr(dy);\n    const t = lenSq === 0 ? -1 : ((x - x1) * dx + (y - y1) * dy) / lenSq;\n    let xx, yy;\n\n    if (t < 0) {\n      xx = x1;\n      yy = y1;\n    } else if (t > 1) {\n      xx = x2;\n      yy = y2;\n    } else {\n      xx = x1 + t * dx;\n      yy = y1 + t * dy;\n    }\n\n    return sqr(x - xx) + sqr(y - yy) < epsilon;\n  }\n\n  labelIsVisible(chartArea) {\n    const label = this.options.label;\n    const inside = !chartArea || isLineInArea(this, chartArea);\n    return inside && label && label.enabled && label.content;\n  }\n\n  isOnLabel(mouseX, mouseY) {\n    const {\n      labelRect\n    } = this;\n\n    if (!labelRect || !this.labelIsVisible()) {\n      return false;\n    }\n\n    const {\n      x,\n      y\n    } = rotated({\n      x: mouseX,\n      y: mouseY\n    }, labelRect, -labelRect.rotation);\n    const w2 = labelRect.width / 2;\n    const h2 = labelRect.height / 2;\n    return x >= labelRect.x - w2 && x <= labelRect.x + w2 && y >= labelRect.y - h2 && y <= labelRect.y + h2;\n  }\n\n  inRange(x, y) {\n    const epsilon = this.options.borderWidth || 1;\n    return this.intersects(x, y, epsilon) || this.isOnLabel(x, y);\n  }\n\n  getCenterPoint() {\n    return {\n      x: (this.x2 + this.x) / 2,\n      y: (this.y2 + this.y) / 2\n    };\n  }\n\n  draw(ctx) {\n    const {\n      x,\n      y,\n      x2,\n      y2,\n      options\n    } = this;\n    ctx.save();\n    ctx.lineWidth = options.borderWidth;\n    ctx.strokeStyle = options.borderColor;\n    ctx.setLineDash(options.borderDash);\n    ctx.lineDashOffset = options.borderDashOffset; // Draw\n\n    ctx.beginPath();\n    ctx.moveTo(x, y);\n    ctx.lineTo(x2, y2);\n    ctx.stroke();\n    ctx.restore();\n  }\n\n  drawLabel(ctx, chartArea) {\n    if (this.labelIsVisible(chartArea)) {\n      ctx.save();\n      drawLabel(ctx, this, chartArea);\n      ctx.restore();\n    }\n  }\n\n  resolveElementProperties(chart, options) {\n    const scale = chart.scales[options.scaleID];\n    let {\n      top: y,\n      left: x,\n      bottom: y2,\n      right: x2\n    } = chart.chartArea;\n    let min, max;\n\n    if (scale) {\n      min = scaleValue(scale, options.value, NaN);\n      max = scaleValue(scale, options.endValue, min);\n\n      if (scale.isHorizontal()) {\n        x = min;\n        x2 = max;\n      } else {\n        y = min;\n        y2 = max;\n      }\n    } else {\n      const xScale = chart.scales[options.xScaleID];\n      const yScale = chart.scales[options.yScaleID];\n\n      if (xScale) {\n        x = scaleValue(xScale, options.xMin, x);\n        x2 = scaleValue(xScale, options.xMax, x2);\n      }\n\n      if (yScale) {\n        y = scaleValue(yScale, options.yMin, y);\n        y2 = scaleValue(yScale, options.yMax, y2);\n      }\n    }\n\n    const inside = isLineInArea({\n      x,\n      y,\n      x2,\n      y2\n    }, chart.chartArea);\n    return inside ? limitLineToArea({\n      x,\n      y\n    }, {\n      x: x2,\n      y: y2\n    }, chart.chartArea) : {\n      x,\n      y,\n      x2,\n      y2,\n      width: Math.abs(x2 - x),\n      height: Math.abs(y2 - y)\n    };\n  }\n\n}\n\nLineAnnotation.id = 'lineAnnotation';\nLineAnnotation.defaults = {\n  display: true,\n  adjustScaleRange: true,\n  borderWidth: 2,\n  borderDash: [],\n  borderDashOffset: 0,\n  label: {\n    backgroundColor: 'rgba(0,0,0,0.8)',\n    borderCapStyle: 'butt',\n    borderColor: 'black',\n    borderDash: [],\n    borderDashOffset: 0,\n    borderJoinStyle: 'miter',\n    borderRadius: 6,\n    borderWidth: 0,\n    drawTime: undefined,\n    font: {\n      family: undefined,\n      lineHeight: undefined,\n      size: undefined,\n      style: undefined,\n      weight: 'bold'\n    },\n    color: '#fff',\n    xPadding: 6,\n    yPadding: 6,\n    rotation: 0,\n    position: 'center',\n    xAdjust: 0,\n    yAdjust: 0,\n    textAlign: 'center',\n    width: undefined,\n    height: undefined,\n    enabled: false,\n    content: null\n  },\n  value: undefined,\n  endValue: undefined,\n  scaleID: undefined,\n  xScaleID: 'x',\n  xMin: undefined,\n  xMax: undefined,\n  yScaleID: 'y',\n  yMin: undefined,\n  yMax: undefined\n};\nLineAnnotation.defaultRoutes = {\n  borderColor: 'color'\n};\n\nfunction calculateAutoRotation(line) {\n  const {\n    x,\n    y,\n    x2,\n    y2\n  } = line;\n  const rotation = Math.atan2(y2 - y, x2 - x); // Flip the rotation if it goes > PI/2 or < -PI/2, so label stays upright\n\n  return rotation > PI / 2 ? rotation - PI : rotation < PI / -2 ? rotation + PI : rotation;\n}\n\nfunction drawLabel(ctx, line, chartArea) {\n  const label = line.options.label;\n  const {\n    borderWidth,\n    xPadding,\n    yPadding,\n    content\n  } = label;\n  const font = toFont(label.font);\n  ctx.font = font.string;\n  const {\n    width,\n    height\n  } = measureLabel(ctx, label, font);\n  const rect = line.labelRect = calculateLabelPosition(line, width, height, chartArea);\n  ctx.translate(rect.x, rect.y);\n  ctx.rotate(rect.rotation);\n  ctx.fillStyle = label.backgroundColor;\n  const stroke = setBorderStyle(ctx, label);\n  ctx.beginPath();\n  addRoundedRectPath(ctx, {\n    x: -(width / 2),\n    y: -(height / 2),\n    w: width,\n    h: height,\n    // TODO: v2 remove support for cornerRadius\n    radius: clampAll(toTRBLCorners(valueOrDefault(label.cornerRadius, label.borderRadius)), 0, Math.min(width, height) / 2)\n  });\n  ctx.closePath();\n  ctx.fill();\n\n  if (stroke) {\n    ctx.stroke();\n  }\n\n  ctx.fillStyle = label.color;\n\n  if (content instanceof Image) {\n    const x = -(width / 2) + xPadding + borderWidth / 2;\n    const y = -(height / 2) + yPadding + borderWidth / 2;\n    ctx.drawImage(content, x, y, width - 2 * xPadding - borderWidth, height - 2 * yPadding - borderWidth);\n  } else {\n    const labels = isArray(content) ? content : [content];\n    const x = calculateLabelXAlignment(label, width);\n    const y = -(labels.length - 1) * font.lineHeight / 2;\n    ctx.textBaseline = 'middle';\n    ctx.textAlign = label.textAlign;\n    labels.forEach((l, i) => ctx.fillText(l, x, y + i * font.lineHeight));\n  }\n}\n\nfunction setBorderStyle(ctx, options) {\n  if (options.borderWidth) {\n    ctx.lineCap = options.borderCapStyle;\n    ctx.setLineDash(options.borderDash);\n    ctx.lineDashOffset = options.borderDashOffset;\n    ctx.lineJoin = options.borderJoinStyle;\n    ctx.lineWidth = options.borderWidth;\n    ctx.strokeStyle = options.borderColor;\n    return true;\n  }\n}\n\nfunction calculateLabelXAlignment(label, width) {\n  const {\n    textAlign,\n    xPadding,\n    borderWidth\n  } = label;\n\n  if (textAlign === 'start') {\n    return -(width / 2) + xPadding + borderWidth / 2;\n  } else if (textAlign === 'end') {\n    return +(width / 2) - xPadding - borderWidth / 2;\n  }\n\n  return 0;\n}\n\nfunction getImageSize(size, value) {\n  if (typeof value === 'number') {\n    return value;\n  } else if (typeof value === 'string') {\n    return toPercent(value) * size;\n  }\n\n  return size;\n}\n\nconst widthCache = new Map();\n\nfunction measureLabel(ctx, label, font) {\n  const content = label.content;\n  const borderWidth = label.borderWidth;\n\n  if (content instanceof Image) {\n    return {\n      width: getImageSize(content.width, label.width) + 2 * label.xPadding + borderWidth,\n      height: getImageSize(content.height, label.height) + 2 * label.yPadding + borderWidth\n    };\n  }\n\n  const lines = isArray(content) ? content : [content];\n  const count = lines.length;\n  let width = 0;\n\n  for (let i = 0; i < count; i++) {\n    const text = lines[i];\n    const key = font.string + '-' + text;\n\n    if (!widthCache.has(key)) {\n      widthCache.set(key, ctx.measureText(text).width);\n    }\n\n    width = Math.max(width, widthCache.get(key));\n  }\n\n  width += 2 * label.xPadding + borderWidth;\n  return {\n    width,\n    height: count * font.lineHeight + label.yPadding * 2 + borderWidth\n  };\n}\n\nfunction calculateLabelPosition(line, width, height, chartArea) {\n  const label = line.options.label;\n  const {\n    xAdjust,\n    yAdjust,\n    xPadding,\n    yPadding,\n    position\n  } = label;\n  const p1 = {\n    x: line.x,\n    y: line.y\n  };\n  const p2 = {\n    x: line.x2,\n    y: line.y2\n  };\n  const rotation = label.rotation === 'auto' ? calculateAutoRotation(line) : toRadians(label.rotation);\n  const size = rotatedSize(width, height, rotation);\n  const t = calculateT(line, position, size, chartArea);\n  const pt = pointInLine(p1, p2, t);\n  const xCoordinateSizes = {\n    size: size.w,\n    min: chartArea.left,\n    max: chartArea.right,\n    padding: xPadding\n  };\n  const yCoordinateSizes = {\n    size: size.h,\n    min: chartArea.top,\n    max: chartArea.bottom,\n    padding: yPadding\n  };\n  return {\n    x: adjustLabelCoordinate(pt.x, xCoordinateSizes) + xAdjust,\n    y: adjustLabelCoordinate(pt.y, yCoordinateSizes) + yAdjust,\n    width,\n    height,\n    rotation\n  };\n}\n\nfunction rotatedSize(width, height, rotation) {\n  const cos = Math.cos(rotation);\n  const sin = Math.sin(rotation);\n  return {\n    w: Math.abs(width * cos) + Math.abs(height * sin),\n    h: Math.abs(width * sin) + Math.abs(height * cos)\n  };\n}\n\nfunction calculateT(line, position, rotSize, chartArea) {\n  let t = 0.5;\n  const space = spaceAround(line, chartArea);\n  const label = line.options.label;\n\n  if (position === 'start') {\n    t = calculateTAdjust({\n      w: line.x2 - line.x,\n      h: line.y2 - line.y\n    }, rotSize, label, space);\n  } else if (position === 'end') {\n    t = 1 - calculateTAdjust({\n      w: line.x - line.x2,\n      h: line.y - line.y2\n    }, rotSize, label, space);\n  }\n\n  return t;\n}\n\nfunction calculateTAdjust(lineSize, labelSize, label, space) {\n  const {\n    xPadding,\n    yPadding\n  } = label;\n  const lineW = lineSize.w * space.dx;\n  const lineH = lineSize.h * space.dy;\n  const x = lineW > 0 && (labelSize.w / 2 + xPadding - space.x) / lineW;\n  const y = lineH > 0 && (labelSize.h / 2 + yPadding - space.y) / lineH;\n  return clamp(Math.max(x, y), 0, 0.25);\n}\n\nfunction spaceAround(line, chartArea) {\n  const {\n    x,\n    x2,\n    y,\n    y2\n  } = line;\n  const t = Math.min(y, y2) - chartArea.top;\n  const l = Math.min(x, x2) - chartArea.left;\n  const b = chartArea.bottom - Math.max(y, y2);\n  const r = chartArea.right - Math.max(x, x2);\n  return {\n    x: Math.min(l, r),\n    y: Math.min(t, b),\n    dx: l < r ? 1 : -1,\n    dy: t < b ? 1 : -1\n  };\n}\n\nfunction adjustLabelCoordinate(coordinate, labelSizes) {\n  const {\n    size,\n    min,\n    max,\n    padding\n  } = labelSizes;\n  const halfSize = size / 2;\n\n  if (size > max - min) {\n    // if it does not fit, display as much as possible\n    return (max + min) / 2;\n  }\n\n  if (min >= coordinate - padding - halfSize) {\n    coordinate = min + padding + halfSize;\n  }\n\n  if (max <= coordinate + padding + halfSize) {\n    coordinate = max - padding - halfSize;\n  }\n\n  return coordinate;\n}\n\nclass EllipseAnnotation extends BoxAnnotation {\n  inRange(x, y) {\n    return pointInEllipse({\n      x,\n      y\n    }, this);\n  }\n\n  draw(ctx) {\n    const {\n      width,\n      height,\n      options\n    } = this;\n    const center = this.getCenterPoint();\n    ctx.save();\n    ctx.translate(center.x, center.y);\n\n    if (options.rotation) {\n      ctx.rotate(toRadians(options.rotation));\n    }\n\n    ctx.beginPath();\n    ctx.lineWidth = options.borderWidth;\n    ctx.strokeStyle = options.borderColor;\n    ctx.fillStyle = options.backgroundColor;\n    ctx.setLineDash(options.borderDash);\n    ctx.lineDashOffset = options.borderDashOffset;\n    ctx.ellipse(0, 0, height / 2, width / 2, Math.PI / 2, 0, 2 * Math.PI);\n    ctx.fill();\n    ctx.stroke();\n    ctx.restore();\n  }\n\n}\n\nEllipseAnnotation.id = 'ellipseAnnotation';\nEllipseAnnotation.defaults = {\n  display: true,\n  adjustScaleRange: true,\n  borderDash: [],\n  borderDashOffset: 0,\n  borderWidth: 1,\n  rotation: 0,\n  xScaleID: 'x',\n  xMin: undefined,\n  xMax: undefined,\n  yScaleID: 'y',\n  yMin: undefined,\n  yMax: undefined\n};\nEllipseAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\n\nfunction pointInEllipse(p, ellipse) {\n  const {\n    width,\n    height\n  } = ellipse;\n  const center = ellipse.getCenterPoint(true);\n  const xRadius = width / 2;\n  const yRadius = height / 2;\n\n  if (xRadius <= 0 || yRadius <= 0) {\n    return false;\n  }\n\n  return Math.pow(p.x - center.x, 2) / Math.pow(xRadius, 2) + Math.pow(p.y - center.y, 2) / Math.pow(yRadius, 2) <= 1.0;\n}\n\nclass PointAnnotation extends Element {\n  inRange(x, y) {\n    const {\n      width,\n      options\n    } = this;\n    const center = this.getCenterPoint(true);\n    const radius = width / 2 + options.borderWidth;\n\n    if (radius <= 0) {\n      return false;\n    }\n\n    return Math.pow(x - center.x, 2) + Math.pow(y - center.y, 2) <= Math.pow(radius, 2);\n  }\n\n  getCenterPoint(useFinalPosition) {\n    const {\n      x,\n      y\n    } = this.getProps(['x', 'y'], useFinalPosition);\n    return {\n      x,\n      y\n    };\n  }\n\n  draw(ctx) {\n    const {\n      x,\n      y,\n      width,\n      options\n    } = this;\n    ctx.save();\n    ctx.lineWidth = options.borderWidth;\n    ctx.strokeStyle = options.borderColor;\n    ctx.fillStyle = options.backgroundColor;\n    ctx.setLineDash(options.borderDash);\n    ctx.lineDashOffset = options.borderDashOffset;\n    ctx.beginPath();\n    ctx.arc(x, y, width / 2, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.stroke();\n    ctx.restore();\n  }\n\n  resolveElementProperties(chart, options) {\n    const {\n      chartArea,\n      scales\n    } = chart;\n    const xScale = scales[options.xScaleID];\n    const yScale = scales[options.yScaleID];\n    let x = chartArea.width / 2;\n    let y = chartArea.height / 2;\n\n    if (xScale) {\n      x = scaleValue(xScale, options.xValue, x);\n    }\n\n    if (yScale) {\n      y = scaleValue(yScale, options.yValue, y);\n    }\n\n    return {\n      x,\n      y,\n      width: options.radius * 2,\n      height: options.radius * 2\n    };\n  }\n\n}\n\nPointAnnotation.id = 'pointAnnotation';\nPointAnnotation.defaults = {\n  display: true,\n  adjustScaleRange: true,\n  borderDash: [],\n  borderDashOffset: 0,\n  borderWidth: 1,\n  radius: 10,\n  xScaleID: 'x',\n  xValue: undefined,\n  yScaleID: 'y',\n  yValue: undefined\n};\nPointAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\nvar version = \"1.1.0\";\nconst chartStates = new Map();\nconst annotationTypes = {\n  box: BoxAnnotation,\n  line: LineAnnotation,\n  ellipse: EllipseAnnotation,\n  point: PointAnnotation\n};\nObject.keys(annotationTypes).forEach(key => {\n  defaults.describe(`elements.${annotationTypes[key].id}`, {\n    _fallback: 'plugins.annotation'\n  });\n});\nvar annotation = {\n  id: 'annotation',\n  version,\n\n  afterRegister() {\n    Chart.register(annotationTypes);\n  },\n\n  afterUnregister() {\n    Chart.unregister(annotationTypes);\n  },\n\n  beforeInit(chart) {\n    chartStates.set(chart, {\n      annotations: [],\n      elements: [],\n      listeners: {},\n      listened: false,\n      moveListened: false\n    });\n  },\n\n  beforeUpdate(chart, args, options) {\n    const state = chartStates.get(chart);\n    const annotations = state.annotations = [];\n    let annotationOptions = options.annotations;\n\n    if (isObject(annotationOptions)) {\n      Object.keys(annotationOptions).forEach(key => {\n        const value = annotationOptions[key];\n\n        if (isObject(value)) {\n          value.id = key;\n          annotations.push(value);\n        }\n      });\n    } else if (isArray(annotationOptions)) {\n      annotations.push(...annotationOptions);\n    }\n  },\n\n  afterDataLimits(chart, args) {\n    const state = chartStates.get(chart);\n    adjustScaleRange(chart, args.scale, state.annotations.filter(a => a.display && a.adjustScaleRange));\n  },\n\n  afterUpdate(chart, args, options) {\n    const state = chartStates.get(chart);\n    updateListeners(chart, state, options);\n    updateElements(chart, state, options, args.mode);\n  },\n\n  beforeDatasetsDraw(chart) {\n    draw(chart, 'beforeDatasetsDraw');\n  },\n\n  afterDatasetsDraw(chart) {\n    draw(chart, 'afterDatasetsDraw');\n  },\n\n  beforeDraw(chart) {\n    draw(chart, 'beforeDraw');\n  },\n\n  afterDraw(chart) {\n    draw(chart, 'afterDraw');\n  },\n\n  beforeEvent(chart, args, options) {\n    const state = chartStates.get(chart);\n    handleEvent(chart, state, args.event, options);\n  },\n\n  destroy(chart) {\n    chartStates.delete(chart);\n  },\n\n  _getState(chart) {\n    return chartStates.get(chart);\n  },\n\n  defaults: {\n    drawTime: 'afterDatasetsDraw',\n    dblClickSpeed: 350,\n    // ms\n    animations: {\n      numbers: {\n        properties: ['x', 'y', 'x2', 'y2', 'width', 'height'],\n        type: 'number'\n      }\n    },\n    label: {\n      drawTime: null\n    }\n  },\n  descriptors: {\n    _indexable: false,\n    _scriptable: prop => !hooks.includes(prop),\n    annotations: {\n      _allKeys: false,\n      _fallback: (prop, opts) => `elements.${annotationTypes[opts.type || 'line'].id}`\n    }\n  },\n  additionalOptionScopes: ['']\n};\nconst directUpdater = {\n  update: Object.assign\n};\n\nfunction resolveAnimations(chart, animOpts, mode) {\n  if (mode === 'reset' || mode === 'none' || mode === 'resize') {\n    return directUpdater;\n  }\n\n  return new Animations(chart, animOpts);\n}\n\nfunction updateElements(chart, state, options, mode) {\n  const animations = resolveAnimations(chart, options.animations, mode);\n  const annotations = state.annotations;\n  const elements = resyncElements(state.elements, annotations);\n\n  for (let i = 0; i < annotations.length; i++) {\n    const annotation = annotations[i];\n    let el = elements[i];\n    const elType = annotationTypes[annotation.type] || annotationTypes.line;\n\n    if (!el || !(el instanceof elType)) {\n      el = elements[i] = new elType();\n    }\n\n    const opts = resolveAnnotationOptions(annotation.setContext(getContext(chart, el, annotation)));\n    const properties = el.resolveElementProperties(chart, opts);\n    properties.skip = isNaN(properties.x) || isNaN(properties.y);\n    properties.options = opts;\n    animations.update(el, properties);\n  }\n}\n\nfunction resolveAnnotationOptions(resolver) {\n  const elType = annotationTypes[resolver.type] || annotationTypes.line;\n  const result = {};\n  result.id = resolver.id;\n  result.type = resolver.type;\n  result.drawTime = resolver.drawTime;\n  Object.assign(result, resolveObj(resolver, elType.defaults), resolveObj(resolver, elType.defaultRoutes));\n\n  for (const hook of hooks) {\n    result[hook] = resolver[hook];\n  }\n\n  return result;\n}\n\nfunction resolveObj(resolver, defs) {\n  const result = {};\n\n  for (const name of Object.keys(defs)) {\n    const optDefs = defs[name];\n    const value = resolver[name];\n    result[name] = isObject(optDefs) ? resolveObj(value, optDefs) : value;\n  }\n\n  return result;\n}\n\nfunction getContext(chart, element, annotation) {\n  return element.$context || (element.$context = Object.assign(Object.create(chart.getContext()), {\n    element,\n    id: annotation.id,\n    type: 'annotation'\n  }));\n}\n\nfunction resyncElements(elements, annotations) {\n  const count = annotations.length;\n  const start = elements.length;\n\n  if (start < count) {\n    const add = count - start;\n    elements.splice(start, 0, ...new Array(add));\n  } else if (start > count) {\n    elements.splice(count, start - count);\n  }\n\n  return elements;\n}\n\nfunction draw(chart, caller) {\n  const {\n    ctx,\n    chartArea\n  } = chart;\n  const state = chartStates.get(chart);\n  const elements = state.elements.filter(el => !el.skip && el.options.display);\n  clipArea(ctx, chartArea);\n  elements.forEach(el => {\n    if (el.options.drawTime === caller) {\n      el.draw(ctx);\n    }\n  });\n  unclipArea(ctx);\n  elements.forEach(el => {\n    if ('drawLabel' in el && el.options.label && (el.options.label.drawTime || el.options.drawTime) === caller) {\n      el.drawLabel(ctx, chartArea);\n    }\n  });\n}\n\nfunction adjustScaleRange(chart, scale, annotations) {\n  const range = getScaleLimits(scale, annotations);\n  let changed = false;\n\n  if (isFinite(range.min) && typeof scale.options.min === 'undefined' && typeof scale.options.suggestedMin === 'undefined') {\n    changed = scale.min !== range.min;\n    scale.min = range.min;\n  }\n\n  if (isFinite(range.max) && typeof scale.options.max === 'undefined' && typeof scale.options.suggestedMax === 'undefined') {\n    changed = scale.max !== range.max;\n    scale.max = range.max;\n  }\n\n  if (changed && typeof scale.handleTickRangeOptions === 'function') {\n    scale.handleTickRangeOptions();\n  }\n}\n\nfunction getScaleLimits(scale, annotations) {\n  const axis = scale.axis;\n  const scaleID = scale.id;\n  const scaleIDOption = axis + 'ScaleID';\n  let min = valueOrDefault(scale.min, Number.NEGATIVE_INFINITY);\n  let max = valueOrDefault(scale.max, Number.POSITIVE_INFINITY);\n\n  for (const annotation of annotations) {\n    if (annotation.scaleID === scaleID) {\n      for (const prop of ['value', 'endValue']) {\n        const raw = annotation[prop];\n\n        if (raw) {\n          const value = scale.parse(raw);\n          min = Math.min(min, value);\n          max = Math.max(max, value);\n        }\n      }\n    } else if (annotation[scaleIDOption] === scaleID) {\n      for (const prop of [axis + 'Min', axis + 'Max', axis + 'Value']) {\n        const raw = annotation[prop];\n\n        if (raw) {\n          const value = scale.parse(raw);\n          min = Math.min(min, value);\n          max = Math.max(max, value);\n        }\n      }\n    }\n  }\n\n  return {\n    min,\n    max\n  };\n}\n\nexport { annotation as default };","map":{"version":3,"sources":["D:/Linh tinh/Money/Gok_lagnooblag/BOTrading_ClientWeb/node_modules/chartjs-plugin-annotation/dist/chartjs-plugin-annotation.esm.js"],"names":["Element","defaults","Chart","Animations","distanceBetweenPoints","callback","isFinite","addRoundedRectPath","toTRBLCorners","valueOrDefault","toFont","isArray","toRadians","isObject","clipArea","unclipArea","clickHooks","moveHooks","hooks","concat","updateListeners","chart","state","options","annotations","listened","moveListened","forEach","hook","listeners","scope","handleEvent","event","type","handleMoveEvents","handleClickEvents","element","getNearestItem","elements","previous","hovered","dispatchMoveEvents","dispatchEvent","leave","enter","elOpts","dblclick","click","clickTimeout","clearTimeout","setTimeout","dblClickSpeed","handler","position","minDistance","Number","POSITIVE_INFINITY","filter","display","inRange","x","y","reduce","nearestItems","center","getCenterPoint","distance","push","sort","a","b","_index","slice","clamp","from","to","Math","min","max","clampAll","obj","key","Object","keys","scaleValue","scale","value","fallback","parse","getPixelForValue","rotated","point","angle","cos","sin","cx","cy","BoxAnnotation","mouseX","mouseY","useFinalPosition","width","height","getProps","draw","ctx","save","lineWidth","borderWidth","strokeStyle","borderColor","fillStyle","backgroundColor","setLineDash","borderDash","lineDashOffset","borderDashOffset","beginPath","w","h","radius","cornerRadius","borderRadius","closePath","fill","stroke","restore","resolveElementProperties","xScale","scales","xScaleID","yScale","yScaleID","top","left","bottom","y2","right","x2","chartArea","xMin","xMax","yMin","yMax","id","adjustScaleRange","undefined","defaultRoutes","PI","pointInLine","p1","p2","t","interpolateX","abs","interpolateY","toPercent","s","endsWith","parseFloat","isLineInArea","limitPointToArea","limitLineToArea","area","LineAnnotation","intersects","epsilon","sqr","v","x1","y1","dx","dy","lenSq","xx","yy","labelIsVisible","label","inside","enabled","content","isOnLabel","labelRect","rotation","w2","h2","moveTo","lineTo","drawLabel","scaleID","NaN","endValue","isHorizontal","borderCapStyle","borderJoinStyle","drawTime","font","family","lineHeight","size","style","weight","color","xPadding","yPadding","xAdjust","yAdjust","textAlign","calculateAutoRotation","line","atan2","string","measureLabel","rect","calculateLabelPosition","translate","rotate","setBorderStyle","Image","drawImage","labels","calculateLabelXAlignment","length","textBaseline","l","i","fillText","lineCap","lineJoin","getImageSize","widthCache","Map","lines","count","text","has","set","measureText","get","rotatedSize","calculateT","pt","xCoordinateSizes","padding","yCoordinateSizes","adjustLabelCoordinate","rotSize","space","spaceAround","calculateTAdjust","lineSize","labelSize","lineW","lineH","r","coordinate","labelSizes","halfSize","EllipseAnnotation","pointInEllipse","ellipse","p","xRadius","yRadius","pow","PointAnnotation","arc","xValue","yValue","version","chartStates","annotationTypes","box","describe","_fallback","annotation","afterRegister","register","afterUnregister","unregister","beforeInit","beforeUpdate","args","annotationOptions","afterDataLimits","afterUpdate","updateElements","mode","beforeDatasetsDraw","afterDatasetsDraw","beforeDraw","afterDraw","beforeEvent","destroy","delete","_getState","animations","numbers","properties","descriptors","_indexable","_scriptable","prop","includes","_allKeys","opts","additionalOptionScopes","directUpdater","update","assign","resolveAnimations","animOpts","resyncElements","el","elType","resolveAnnotationOptions","setContext","getContext","skip","isNaN","resolver","result","resolveObj","defs","name","optDefs","$context","create","start","add","splice","Array","caller","range","getScaleLimits","changed","suggestedMin","suggestedMax","handleTickRangeOptions","axis","scaleIDOption","NEGATIVE_INFINITY","raw","default"],"mappings":"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","sourcesContent":["/*!\n* chartjs-plugin-annotation v1.1.0\n* https://www.chartjs.org/chartjs-plugin-annotation/index\n * (c) 2021 chartjs-plugin-annotation Contributors\n * Released under the MIT License\n */\nimport { Element, defaults, Chart, Animations } from 'chart.js';\nimport { distanceBetweenPoints, callback, isFinite, addRoundedRectPath, toTRBLCorners, valueOrDefault, toFont, isArray, toRadians, isObject, clipArea, unclipArea } from 'chart.js/helpers';\n\nconst clickHooks = ['click', 'dblclick'];\nconst moveHooks = ['enter', 'leave'];\nconst hooks = clickHooks.concat(moveHooks);\n\nfunction updateListeners(chart, state, options) {\n  const annotations = state.annotations || [];\n  state.listened = false;\n  state.moveListened = false;\n\n  hooks.forEach(hook => {\n    if (typeof options[hook] === 'function') {\n      state.listened = true;\n      state.listeners[hook] = options[hook];\n    }\n  });\n  moveHooks.forEach(hook => {\n    if (typeof options[hook] === 'function') {\n      state.moveListened = true;\n    }\n  });\n\n  if (!state.listened || !state.moveListened) {\n    annotations.forEach(scope => {\n      if (!state.listened) {\n        clickHooks.forEach(hook => {\n          if (typeof scope[hook] === 'function') {\n            state.listened = true;\n          }\n        });\n      }\n      if (!state.moveListened) {\n        moveHooks.forEach(hook => {\n          if (typeof scope[hook] === 'function') {\n            state.listened = true;\n            state.moveListened = true;\n          }\n        });\n      }\n    });\n  }\n}\n\nfunction handleEvent(chart, state, event, options) {\n  if (state.listened) {\n    switch (event.type) {\n    case 'mousemove':\n    case 'mouseout':\n      handleMoveEvents(chart, state, event);\n      break;\n    case 'click':\n      handleClickEvents(chart, state, event, options);\n      break;\n    }\n  }\n}\n\nfunction handleMoveEvents(chart, state, event) {\n  if (!state.moveListened) {\n    return;\n  }\n\n  let element;\n\n  if (event.type === 'mousemove') {\n    element = getNearestItem(state.elements, event);\n  }\n\n  const previous = state.hovered;\n  state.hovered = element;\n\n  dispatchMoveEvents(chart, state, {previous, element}, event);\n}\n\nfunction dispatchMoveEvents(chart, state, elements, event) {\n  const {previous, element} = elements;\n  if (previous && previous !== element) {\n    dispatchEvent(chart, previous.options.leave || state.listeners.leave, previous, event);\n  }\n  if (element && element !== previous) {\n    dispatchEvent(chart, element.options.enter || state.listeners.enter, element, event);\n  }\n}\n\nfunction handleClickEvents(chart, state, event, options) {\n  const listeners = state.listeners;\n  const element = getNearestItem(state.elements, event);\n  if (element) {\n    const elOpts = element.options;\n    const dblclick = elOpts.dblclick || listeners.dblclick;\n    const click = elOpts.click || listeners.click;\n    if (element.clickTimeout) {\n      // 2nd click before timeout, so its a double click\n      clearTimeout(element.clickTimeout);\n      delete element.clickTimeout;\n      dispatchEvent(chart, dblclick, element, event);\n    } else if (dblclick) {\n      // if there is a dblclick handler, wait for dblClickSpeed ms before deciding its a click\n      element.clickTimeout = setTimeout(() => {\n        delete element.clickTimeout;\n        dispatchEvent(chart, click, element, event);\n      }, options.dblClickSpeed);\n    } else {\n      // no double click handler, just call the click handler directly\n      dispatchEvent(chart, click, element, event);\n    }\n  }\n}\n\nfunction dispatchEvent(chart, handler, element, event) {\n  callback(handler, [{chart, element}, event]);\n}\n\nfunction getNearestItem(elements, position) {\n  let minDistance = Number.POSITIVE_INFINITY;\n\n  return elements\n    .filter((element) => element.options.display && element.inRange(position.x, position.y))\n    .reduce((nearestItems, element) => {\n      const center = element.getCenterPoint();\n      const distance = distanceBetweenPoints(position, center);\n\n      if (distance < minDistance) {\n        nearestItems = [element];\n        minDistance = distance;\n      } else if (distance === minDistance) {\n        // Can have multiple items at the same distance in which case we sort by size\n        nearestItems.push(element);\n      }\n\n      return nearestItems;\n    }, [])\n    .sort((a, b) => a._index - b._index)\n    .slice(0, 1)[0]; // return only the top item\n}\n\nconst clamp = (x, from, to) => Math.min(to, Math.max(from, x));\n\nfunction clampAll(obj, from, to) {\n  for (const key of Object.keys(obj)) {\n    obj[key] = clamp(obj[key], from, to);\n  }\n  return obj;\n}\n\nfunction scaleValue(scale, value, fallback) {\n  value = typeof value === 'number' ? value : scale.parse(value);\n  return isFinite(value) ? scale.getPixelForValue(value) : fallback;\n}\n\n/**\n * Rotate a `point` relative to `center` point by `angle`\n * @param {{x: number, y: number}} point - the point to rotate\n * @param {{x: number, y: number}} center - center point for rotation\n * @param {number} angle - angle for rotation, in radians\n * @returns {{x: number, y: number}} rotated point\n */\nfunction rotated(point, center, angle) {\n  var cos = Math.cos(angle);\n  var sin = Math.sin(angle);\n  var cx = center.x;\n  var cy = center.y;\n\n  return {\n    x: cx + cos * (point.x - cx) - sin * (point.y - cy),\n    y: cy + sin * (point.x - cx) + cos * (point.y - cy)\n  };\n}\n\nclass BoxAnnotation extends Element {\n  inRange(mouseX, mouseY, useFinalPosition) {\n    const {x, y, width, height} = this.getProps(['x', 'y', 'width', 'height'], useFinalPosition);\n\n    return mouseX >= x &&\n\t\t\tmouseX <= x + width &&\n\t\t\tmouseY >= y &&\n\t\t\tmouseY <= y + height;\n  }\n\n  getCenterPoint(useFinalPosition) {\n    const {x, y, width, height} = this.getProps(['x', 'y', 'width', 'height'], useFinalPosition);\n    return {\n      x: x + width / 2,\n      y: y + height / 2\n    };\n  }\n\n  draw(ctx) {\n    const {x, y, width, height, options} = this;\n\n    ctx.save();\n\n    ctx.lineWidth = options.borderWidth;\n    ctx.strokeStyle = options.borderColor;\n    ctx.fillStyle = options.backgroundColor;\n\n    ctx.setLineDash(options.borderDash);\n    ctx.lineDashOffset = options.borderDashOffset;\n\n    ctx.beginPath();\n    addRoundedRectPath(ctx, {\n      x, y, w: width, h: height,\n      // TODO: v2 remove support for cornerRadius\n      radius: clampAll(toTRBLCorners(valueOrDefault(options.cornerRadius, options.borderRadius)), 0, Math.min(width, height) / 2)\n    });\n    ctx.closePath();\n    ctx.fill();\n\n    // If no border, don't draw it\n    if (options.borderWidth) {\n      ctx.stroke();\n    }\n\n    ctx.restore();\n  }\n\n  resolveElementProperties(chart, options) {\n    const xScale = chart.scales[options.xScaleID];\n    const yScale = chart.scales[options.yScaleID];\n    let {top: y, left: x, bottom: y2, right: x2} = chart.chartArea;\n    let min, max;\n\n    if (!xScale && !yScale) {\n      return {options: {}};\n    }\n\n    if (xScale) {\n      min = scaleValue(xScale, options.xMin, x);\n      max = scaleValue(xScale, options.xMax, x2);\n      x = Math.min(min, max);\n      x2 = Math.max(min, max);\n    }\n\n    if (yScale) {\n      min = scaleValue(yScale, options.yMin, y2);\n      max = scaleValue(yScale, options.yMax, y);\n      y = Math.min(min, max);\n      y2 = Math.max(min, max);\n    }\n\n    return {\n      x,\n      y,\n      x2,\n      y2,\n      width: x2 - x,\n      height: y2 - y\n    };\n  }\n}\n\nBoxAnnotation.id = 'boxAnnotation';\n\nBoxAnnotation.defaults = {\n  display: true,\n  adjustScaleRange: true,\n  borderDash: [],\n  borderDashOffset: 0,\n  borderWidth: 1,\n  borderRadius: 0,\n  xScaleID: 'x',\n  xMin: undefined,\n  xMax: undefined,\n  yScaleID: 'y',\n  yMin: undefined,\n  yMax: undefined\n};\n\nBoxAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\n\nconst PI = Math.PI;\nconst pointInLine = (p1, p2, t) => ({x: p1.x + t * (p2.x - p1.x), y: p1.y + t * (p2.y - p1.y)});\nconst interpolateX = (y, p1, p2) => pointInLine(p1, p2, Math.abs((y - p1.y) / (p2.y - p1.y))).x;\nconst interpolateY = (x, p1, p2) => pointInLine(p1, p2, Math.abs((x - p1.x) / (p2.x - p1.x))).y;\nconst toPercent = (s) => typeof s === 'string' && s.endsWith('%') && parseFloat(s) / 100;\n\nfunction isLineInArea({x, y, x2, y2}, {top, right, bottom, left}) {\n  return !(\n    (x < left && x2 < left) ||\n    (x > right && x2 > right) ||\n    (y < top && y2 < top) ||\n    (y > bottom && y2 > bottom)\n  );\n}\n\nfunction limitPointToArea({x, y}, p2, {top, right, bottom, left}) {\n  if (x < left) {\n    y = interpolateY(left, {x, y}, p2);\n    x = left;\n  }\n  if (x > right) {\n    y = interpolateY(right, {x, y}, p2);\n    x = right;\n  }\n  if (y < top) {\n    x = interpolateX(top, {x, y}, p2);\n    y = top;\n  }\n  if (y > bottom) {\n    x = interpolateX(bottom, {x, y}, p2);\n    y = bottom;\n  }\n  return {x, y};\n}\n\nfunction limitLineToArea(p1, p2, area) {\n  const {x, y} = limitPointToArea(p1, p2, area);\n  const {x: x2, y: y2} = limitPointToArea(p2, p1, area);\n  return {x, y, x2, y2, width: Math.abs(x2 - x), height: Math.abs(y2 - y)};\n}\n\nclass LineAnnotation extends Element {\n  intersects(x, y, epsilon = 0.001) {\n    // Adapted from https://stackoverflow.com/a/6853926/25507\n    const sqr = v => v * v;\n    const {x: x1, y: y1, x2, y2} = this;\n    const dx = x2 - x1;\n    const dy = y2 - y1;\n    const lenSq = sqr(dx) + sqr(dy);\n    const t = lenSq === 0 ? -1 : ((x - x1) * dx + (y - y1) * dy) / lenSq;\n    let xx, yy;\n    if (t < 0) {\n      xx = x1;\n      yy = y1;\n    } else if (t > 1) {\n      xx = x2;\n      yy = y2;\n    } else {\n      xx = x1 + t * dx;\n      yy = y1 + t * dy;\n    }\n    return (sqr(x - xx) + sqr(y - yy)) < epsilon;\n  }\n\n  labelIsVisible(chartArea) {\n    const label = this.options.label;\n\n    const inside = !chartArea || isLineInArea(this, chartArea);\n    return inside && label && label.enabled && label.content;\n  }\n\n  isOnLabel(mouseX, mouseY) {\n    const {labelRect} = this;\n    if (!labelRect || !this.labelIsVisible()) {\n      return false;\n    }\n\n    const {x, y} = rotated({x: mouseX, y: mouseY}, labelRect, -labelRect.rotation);\n    const w2 = labelRect.width / 2;\n    const h2 = labelRect.height / 2;\n    return x >= labelRect.x - w2 && x <= labelRect.x + w2 &&\n      y >= labelRect.y - h2 && y <= labelRect.y + h2;\n  }\n\n  inRange(x, y) {\n    const epsilon = this.options.borderWidth || 1;\n    return this.intersects(x, y, epsilon) || this.isOnLabel(x, y);\n  }\n\n  getCenterPoint() {\n    return {\n      x: (this.x2 + this.x) / 2,\n      y: (this.y2 + this.y) / 2\n    };\n  }\n\n  draw(ctx) {\n    const {x, y, x2, y2, options} = this;\n    ctx.save();\n\n    ctx.lineWidth = options.borderWidth;\n    ctx.strokeStyle = options.borderColor;\n    ctx.setLineDash(options.borderDash);\n    ctx.lineDashOffset = options.borderDashOffset;\n\n    // Draw\n    ctx.beginPath();\n    ctx.moveTo(x, y);\n    ctx.lineTo(x2, y2);\n    ctx.stroke();\n\n    ctx.restore();\n  }\n\n  drawLabel(ctx, chartArea) {\n    if (this.labelIsVisible(chartArea)) {\n      ctx.save();\n      drawLabel(ctx, this, chartArea);\n      ctx.restore();\n    }\n  }\n\n  resolveElementProperties(chart, options) {\n    const scale = chart.scales[options.scaleID];\n    let {top: y, left: x, bottom: y2, right: x2} = chart.chartArea;\n    let min, max;\n\n    if (scale) {\n      min = scaleValue(scale, options.value, NaN);\n      max = scaleValue(scale, options.endValue, min);\n      if (scale.isHorizontal()) {\n        x = min;\n        x2 = max;\n      } else {\n        y = min;\n        y2 = max;\n      }\n    } else {\n      const xScale = chart.scales[options.xScaleID];\n      const yScale = chart.scales[options.yScaleID];\n\n      if (xScale) {\n        x = scaleValue(xScale, options.xMin, x);\n        x2 = scaleValue(xScale, options.xMax, x2);\n      }\n\n      if (yScale) {\n        y = scaleValue(yScale, options.yMin, y);\n        y2 = scaleValue(yScale, options.yMax, y2);\n      }\n    }\n    const inside = isLineInArea({x, y, x2, y2}, chart.chartArea);\n    return inside\n      ? limitLineToArea({x, y}, {x: x2, y: y2}, chart.chartArea)\n      : {x, y, x2, y2, width: Math.abs(x2 - x), height: Math.abs(y2 - y)};\n  }\n}\n\nLineAnnotation.id = 'lineAnnotation';\nLineAnnotation.defaults = {\n  display: true,\n  adjustScaleRange: true,\n  borderWidth: 2,\n  borderDash: [],\n  borderDashOffset: 0,\n  label: {\n    backgroundColor: 'rgba(0,0,0,0.8)',\n    borderCapStyle: 'butt',\n    borderColor: 'black',\n    borderDash: [],\n    borderDashOffset: 0,\n    borderJoinStyle: 'miter',\n    borderRadius: 6,\n    borderWidth: 0,\n    drawTime: undefined,\n    font: {\n      family: undefined,\n      lineHeight: undefined,\n      size: undefined,\n      style: undefined,\n      weight: 'bold'\n    },\n    color: '#fff',\n    xPadding: 6,\n    yPadding: 6,\n    rotation: 0,\n    position: 'center',\n    xAdjust: 0,\n    yAdjust: 0,\n    textAlign: 'center',\n    width: undefined,\n    height: undefined,\n    enabled: false,\n    content: null\n  },\n  value: undefined,\n  endValue: undefined,\n  scaleID: undefined,\n  xScaleID: 'x',\n  xMin: undefined,\n  xMax: undefined,\n  yScaleID: 'y',\n  yMin: undefined,\n  yMax: undefined\n};\n\nLineAnnotation.defaultRoutes = {\n  borderColor: 'color'\n};\n\nfunction calculateAutoRotation(line) {\n  const {x, y, x2, y2} = line;\n  const rotation = Math.atan2(y2 - y, x2 - x);\n  // Flip the rotation if it goes > PI/2 or < -PI/2, so label stays upright\n  return rotation > PI / 2 ? rotation - PI : rotation < PI / -2 ? rotation + PI : rotation;\n}\n\nfunction drawLabel(ctx, line, chartArea) {\n  const label = line.options.label;\n  const {borderWidth, xPadding, yPadding, content} = label;\n  const font = toFont(label.font);\n  ctx.font = font.string;\n\n  const {width, height} = measureLabel(ctx, label, font);\n  const rect = line.labelRect = calculateLabelPosition(line, width, height, chartArea);\n\n  ctx.translate(rect.x, rect.y);\n  ctx.rotate(rect.rotation);\n\n  ctx.fillStyle = label.backgroundColor;\n  const stroke = setBorderStyle(ctx, label);\n\n  ctx.beginPath();\n  addRoundedRectPath(ctx, {\n    x: -(width / 2), y: -(height / 2), w: width, h: height,\n    // TODO: v2 remove support for cornerRadius\n    radius: clampAll(toTRBLCorners(valueOrDefault(label.cornerRadius, label.borderRadius)), 0, Math.min(width, height) / 2)\n  });\n  ctx.closePath();\n  ctx.fill();\n  if (stroke) {\n    ctx.stroke();\n  }\n\n  ctx.fillStyle = label.color;\n  if (content instanceof Image) {\n    const x = -(width / 2) + xPadding + borderWidth / 2;\n    const y = -(height / 2) + yPadding + borderWidth / 2;\n    ctx.drawImage(content, x, y, width - (2 * xPadding) - borderWidth, height - (2 * yPadding) - borderWidth);\n  } else {\n    const labels = isArray(content) ? content : [content];\n    const x = calculateLabelXAlignment(label, width);\n    const y = -(labels.length - 1) * font.lineHeight / 2;\n    ctx.textBaseline = 'middle';\n    ctx.textAlign = label.textAlign;\n    labels.forEach((l, i) => ctx.fillText(l, x, y + (i * font.lineHeight)));\n  }\n}\n\nfunction setBorderStyle(ctx, options) {\n  if (options.borderWidth) {\n    ctx.lineCap = options.borderCapStyle;\n    ctx.setLineDash(options.borderDash);\n    ctx.lineDashOffset = options.borderDashOffset;\n    ctx.lineJoin = options.borderJoinStyle;\n    ctx.lineWidth = options.borderWidth;\n    ctx.strokeStyle = options.borderColor;\n    return true;\n  }\n}\n\nfunction calculateLabelXAlignment(label, width) {\n  const {textAlign, xPadding, borderWidth} = label;\n  if (textAlign === 'start') {\n    return -(width / 2) + xPadding + borderWidth / 2;\n  } else if (textAlign === 'end') {\n    return +(width / 2) - xPadding - borderWidth / 2;\n  }\n  return 0;\n}\n\nfunction getImageSize(size, value) {\n  if (typeof value === 'number') {\n    return value;\n  } else if (typeof value === 'string') {\n    return toPercent(value) * size;\n  }\n  return size;\n}\n\nconst widthCache = new Map();\nfunction measureLabel(ctx, label, font) {\n  const content = label.content;\n  const borderWidth = label.borderWidth;\n\n  if (content instanceof Image) {\n    return {\n      width: getImageSize(content.width, label.width) + 2 * label.xPadding + borderWidth,\n      height: getImageSize(content.height, label.height) + 2 * label.yPadding + borderWidth\n    };\n  }\n  const lines = isArray(content) ? content : [content];\n  const count = lines.length;\n  let width = 0;\n  for (let i = 0; i < count; i++) {\n    const text = lines[i];\n    const key = font.string + '-' + text;\n    if (!widthCache.has(key)) {\n      widthCache.set(key, ctx.measureText(text).width);\n    }\n    width = Math.max(width, widthCache.get(key));\n  }\n  width += 2 * label.xPadding + borderWidth;\n\n  return {\n    width,\n    height: count * font.lineHeight + label.yPadding * 2 + borderWidth\n  };\n}\n\nfunction calculateLabelPosition(line, width, height, chartArea) {\n  const label = line.options.label;\n  const {xAdjust, yAdjust, xPadding, yPadding, position} = label;\n  const p1 = {x: line.x, y: line.y};\n  const p2 = {x: line.x2, y: line.y2};\n  const rotation = label.rotation === 'auto' ? calculateAutoRotation(line) : toRadians(label.rotation);\n  const size = rotatedSize(width, height, rotation);\n  const t = calculateT(line, position, size, chartArea);\n  const pt = pointInLine(p1, p2, t);\n  const xCoordinateSizes = {size: size.w, min: chartArea.left, max: chartArea.right, padding: xPadding};\n  const yCoordinateSizes = {size: size.h, min: chartArea.top, max: chartArea.bottom, padding: yPadding};\n\n  return {\n    x: adjustLabelCoordinate(pt.x, xCoordinateSizes) + xAdjust,\n    y: adjustLabelCoordinate(pt.y, yCoordinateSizes) + yAdjust,\n    width,\n    height,\n    rotation\n  };\n}\n\nfunction rotatedSize(width, height, rotation) {\n  const cos = Math.cos(rotation);\n  const sin = Math.sin(rotation);\n  return {\n    w: Math.abs(width * cos) + Math.abs(height * sin),\n    h: Math.abs(width * sin) + Math.abs(height * cos)\n  };\n}\n\nfunction calculateT(line, position, rotSize, chartArea) {\n  let t = 0.5;\n  const space = spaceAround(line, chartArea);\n  const label = line.options.label;\n  if (position === 'start') {\n    t = calculateTAdjust({w: line.x2 - line.x, h: line.y2 - line.y}, rotSize, label, space);\n  } else if (position === 'end') {\n    t = 1 - calculateTAdjust({w: line.x - line.x2, h: line.y - line.y2}, rotSize, label, space);\n  }\n  return t;\n}\n\nfunction calculateTAdjust(lineSize, labelSize, label, space) {\n  const {xPadding, yPadding} = label;\n  const lineW = lineSize.w * space.dx;\n  const lineH = lineSize.h * space.dy;\n  const x = (lineW > 0) && ((labelSize.w / 2 + xPadding - space.x) / lineW);\n  const y = (lineH > 0) && ((labelSize.h / 2 + yPadding - space.y) / lineH);\n  return clamp(Math.max(x, y), 0, 0.25);\n}\n\nfunction spaceAround(line, chartArea) {\n  const {x, x2, y, y2} = line;\n  const t = Math.min(y, y2) - chartArea.top;\n  const l = Math.min(x, x2) - chartArea.left;\n  const b = chartArea.bottom - Math.max(y, y2);\n  const r = chartArea.right - Math.max(x, x2);\n  return {\n    x: Math.min(l, r),\n    y: Math.min(t, b),\n    dx: l < r ? 1 : -1,\n    dy: t < b ? 1 : -1\n  };\n}\n\nfunction adjustLabelCoordinate(coordinate, labelSizes) {\n  const {size, min, max, padding} = labelSizes;\n  const halfSize = size / 2;\n\n  if (size > max - min) {\n    // if it does not fit, display as much as possible\n    return (max + min) / 2;\n  }\n\n  if (min >= (coordinate - padding - halfSize)) {\n    coordinate = min + padding + halfSize;\n  }\n\n  if (max <= (coordinate + padding + halfSize)) {\n    coordinate = max - padding - halfSize;\n  }\n\n  return coordinate;\n}\n\nclass EllipseAnnotation extends BoxAnnotation {\n\n  inRange(x, y) {\n    return pointInEllipse({x, y}, this);\n  }\n\n  draw(ctx) {\n    const {width, height, options} = this;\n    const center = this.getCenterPoint();\n\n    ctx.save();\n\n    ctx.translate(center.x, center.y);\n    if (options.rotation) {\n      ctx.rotate(toRadians(options.rotation));\n    }\n\n    ctx.beginPath();\n\n    ctx.lineWidth = options.borderWidth;\n    ctx.strokeStyle = options.borderColor;\n    ctx.fillStyle = options.backgroundColor;\n\n    ctx.setLineDash(options.borderDash);\n    ctx.lineDashOffset = options.borderDashOffset;\n\n    ctx.ellipse(0, 0, height / 2, width / 2, Math.PI / 2, 0, 2 * Math.PI);\n\n    ctx.fill();\n    ctx.stroke();\n\n    ctx.restore();\n  }\n}\n\nEllipseAnnotation.id = 'ellipseAnnotation';\n\nEllipseAnnotation.defaults = {\n  display: true,\n  adjustScaleRange: true,\n  borderDash: [],\n  borderDashOffset: 0,\n  borderWidth: 1,\n  rotation: 0,\n  xScaleID: 'x',\n  xMin: undefined,\n  xMax: undefined,\n  yScaleID: 'y',\n  yMin: undefined,\n  yMax: undefined\n};\n\nEllipseAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\n\nfunction pointInEllipse(p, ellipse) {\n  const {width, height} = ellipse;\n  const center = ellipse.getCenterPoint(true);\n  const xRadius = width / 2;\n  const yRadius = height / 2;\n\n  if (xRadius <= 0 || yRadius <= 0) {\n    return false;\n  }\n\n  return (Math.pow(p.x - center.x, 2) / Math.pow(xRadius, 2)) + (Math.pow(p.y - center.y, 2) / Math.pow(yRadius, 2)) <= 1.0;\n}\n\nclass PointAnnotation extends Element {\n\n  inRange(x, y) {\n    const {width, options} = this;\n    const center = this.getCenterPoint(true);\n    const radius = width / 2 + options.borderWidth;\n\n    if (radius <= 0) {\n      return false;\n    }\n\n    return (Math.pow(x - center.x, 2) + Math.pow(y - center.y, 2)) <= Math.pow(radius, 2);\n  }\n\n  getCenterPoint(useFinalPosition) {\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\n    return {x, y};\n  }\n\n  draw(ctx) {\n    const {x, y, width, options} = this;\n\n    ctx.save();\n\n    ctx.lineWidth = options.borderWidth;\n    ctx.strokeStyle = options.borderColor;\n    ctx.fillStyle = options.backgroundColor;\n\n    ctx.setLineDash(options.borderDash);\n    ctx.lineDashOffset = options.borderDashOffset;\n\n    ctx.beginPath();\n    ctx.arc(x, y, width / 2, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.stroke();\n\n    ctx.restore();\n  }\n\n  resolveElementProperties(chart, options) {\n    const {chartArea, scales} = chart;\n    const xScale = scales[options.xScaleID];\n    const yScale = scales[options.yScaleID];\n    let x = chartArea.width / 2;\n    let y = chartArea.height / 2;\n\n    if (xScale) {\n      x = scaleValue(xScale, options.xValue, x);\n    }\n\n    if (yScale) {\n      y = scaleValue(yScale, options.yValue, y);\n    }\n\n    return {\n      x,\n      y,\n      width: options.radius * 2,\n      height: options.radius * 2\n    };\n  }\n}\n\nPointAnnotation.id = 'pointAnnotation';\n\nPointAnnotation.defaults = {\n  display: true,\n  adjustScaleRange: true,\n  borderDash: [],\n  borderDashOffset: 0,\n  borderWidth: 1,\n  radius: 10,\n  xScaleID: 'x',\n  xValue: undefined,\n  yScaleID: 'y',\n  yValue: undefined\n};\n\nPointAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\n\nvar version = \"1.1.0\";\n\nconst chartStates = new Map();\n\nconst annotationTypes = {\n  box: BoxAnnotation,\n  line: LineAnnotation,\n  ellipse: EllipseAnnotation,\n  point: PointAnnotation\n};\n\nObject.keys(annotationTypes).forEach(key => {\n  defaults.describe(`elements.${annotationTypes[key].id}`, {\n    _fallback: 'plugins.annotation'\n  });\n});\n\nvar annotation = {\n  id: 'annotation',\n\n  version,\n\n  afterRegister() {\n    Chart.register(annotationTypes);\n  },\n\n  afterUnregister() {\n    Chart.unregister(annotationTypes);\n  },\n\n  beforeInit(chart) {\n    chartStates.set(chart, {\n      annotations: [],\n      elements: [],\n      listeners: {},\n      listened: false,\n      moveListened: false\n    });\n  },\n\n  beforeUpdate(chart, args, options) {\n    const state = chartStates.get(chart);\n    const annotations = state.annotations = [];\n\n    let annotationOptions = options.annotations;\n    if (isObject(annotationOptions)) {\n      Object.keys(annotationOptions).forEach(key => {\n        const value = annotationOptions[key];\n        if (isObject(value)) {\n          value.id = key;\n          annotations.push(value);\n        }\n      });\n    } else if (isArray(annotationOptions)) {\n      annotations.push(...annotationOptions);\n    }\n  },\n\n  afterDataLimits(chart, args) {\n    const state = chartStates.get(chart);\n    adjustScaleRange(chart, args.scale, state.annotations.filter(a => a.display && a.adjustScaleRange));\n  },\n\n  afterUpdate(chart, args, options) {\n    const state = chartStates.get(chart);\n    updateListeners(chart, state, options);\n    updateElements(chart, state, options, args.mode);\n  },\n\n  beforeDatasetsDraw(chart) {\n    draw(chart, 'beforeDatasetsDraw');\n  },\n\n  afterDatasetsDraw(chart) {\n    draw(chart, 'afterDatasetsDraw');\n  },\n\n  beforeDraw(chart) {\n    draw(chart, 'beforeDraw');\n  },\n\n  afterDraw(chart) {\n    draw(chart, 'afterDraw');\n  },\n\n  beforeEvent(chart, args, options) {\n    const state = chartStates.get(chart);\n    handleEvent(chart, state, args.event, options);\n  },\n\n  destroy(chart) {\n    chartStates.delete(chart);\n  },\n\n  _getState(chart) {\n    return chartStates.get(chart);\n  },\n\n  defaults: {\n    drawTime: 'afterDatasetsDraw',\n    dblClickSpeed: 350, // ms\n    animations: {\n      numbers: {\n        properties: ['x', 'y', 'x2', 'y2', 'width', 'height'],\n        type: 'number'\n      },\n    },\n    label: {\n      drawTime: null\n    }\n  },\n\n  descriptors: {\n    _indexable: false,\n    _scriptable: (prop) => !hooks.includes(prop),\n    annotations: {\n      _allKeys: false,\n      _fallback: (prop, opts) => `elements.${annotationTypes[opts.type || 'line'].id}`,\n    },\n  },\n\n  additionalOptionScopes: ['']\n};\n\nconst directUpdater = {\n  update: Object.assign\n};\n\nfunction resolveAnimations(chart, animOpts, mode) {\n  if (mode === 'reset' || mode === 'none' || mode === 'resize') {\n    return directUpdater;\n  }\n  return new Animations(chart, animOpts);\n}\n\nfunction updateElements(chart, state, options, mode) {\n  const animations = resolveAnimations(chart, options.animations, mode);\n\n  const annotations = state.annotations;\n  const elements = resyncElements(state.elements, annotations);\n\n  for (let i = 0; i < annotations.length; i++) {\n    const annotation = annotations[i];\n    let el = elements[i];\n    const elType = annotationTypes[annotation.type] || annotationTypes.line;\n    if (!el || !(el instanceof elType)) {\n      el = elements[i] = new elType();\n    }\n    const opts = resolveAnnotationOptions(annotation.setContext(getContext(chart, el, annotation)));\n    const properties = el.resolveElementProperties(chart, opts);\n    properties.skip = isNaN(properties.x) || isNaN(properties.y);\n    properties.options = opts;\n    animations.update(el, properties);\n  }\n}\n\nfunction resolveAnnotationOptions(resolver) {\n  const elType = annotationTypes[resolver.type] || annotationTypes.line;\n  const result = {};\n  result.id = resolver.id;\n  result.type = resolver.type;\n  result.drawTime = resolver.drawTime;\n  Object.assign(result, resolveObj(resolver, elType.defaults), resolveObj(resolver, elType.defaultRoutes));\n  for (const hook of hooks) {\n    result[hook] = resolver[hook];\n  }\n  return result;\n}\n\nfunction resolveObj(resolver, defs) {\n  const result = {};\n  for (const name of Object.keys(defs)) {\n    const optDefs = defs[name];\n    const value = resolver[name];\n    result[name] = isObject(optDefs) ? resolveObj(value, optDefs) : value;\n  }\n  return result;\n}\n\nfunction getContext(chart, element, annotation) {\n  return element.$context || (element.$context = Object.assign(Object.create(chart.getContext()), {\n    element,\n    id: annotation.id,\n    type: 'annotation'\n  }));\n}\n\nfunction resyncElements(elements, annotations) {\n  const count = annotations.length;\n  const start = elements.length;\n\n  if (start < count) {\n    const add = count - start;\n    elements.splice(start, 0, ...new Array(add));\n  } else if (start > count) {\n    elements.splice(count, start - count);\n  }\n  return elements;\n}\n\nfunction draw(chart, caller) {\n  const {ctx, chartArea} = chart;\n  const state = chartStates.get(chart);\n  const elements = state.elements.filter(el => !el.skip && el.options.display);\n\n  clipArea(ctx, chartArea);\n  elements.forEach(el => {\n    if (el.options.drawTime === caller) {\n      el.draw(ctx);\n    }\n  });\n  unclipArea(ctx);\n\n  elements.forEach(el => {\n    if ('drawLabel' in el && el.options.label && (el.options.label.drawTime || el.options.drawTime) === caller) {\n      el.drawLabel(ctx, chartArea);\n    }\n  });\n}\n\nfunction adjustScaleRange(chart, scale, annotations) {\n  const range = getScaleLimits(scale, annotations);\n  let changed = false;\n  if (isFinite(range.min) &&\n\t\ttypeof scale.options.min === 'undefined' &&\n\t\ttypeof scale.options.suggestedMin === 'undefined') {\n    changed = scale.min !== range.min;\n    scale.min = range.min;\n  }\n  if (isFinite(range.max) &&\n\t\ttypeof scale.options.max === 'undefined' &&\n\t\ttypeof scale.options.suggestedMax === 'undefined') {\n    changed = scale.max !== range.max;\n    scale.max = range.max;\n  }\n  if (changed && typeof scale.handleTickRangeOptions === 'function') {\n    scale.handleTickRangeOptions();\n  }\n}\n\nfunction getScaleLimits(scale, annotations) {\n  const axis = scale.axis;\n  const scaleID = scale.id;\n  const scaleIDOption = axis + 'ScaleID';\n  let min = valueOrDefault(scale.min, Number.NEGATIVE_INFINITY);\n  let max = valueOrDefault(scale.max, Number.POSITIVE_INFINITY);\n  for (const annotation of annotations) {\n    if (annotation.scaleID === scaleID) {\n      for (const prop of ['value', 'endValue']) {\n        const raw = annotation[prop];\n        if (raw) {\n          const value = scale.parse(raw);\n          min = Math.min(min, value);\n          max = Math.max(max, value);\n        }\n      }\n    } else if (annotation[scaleIDOption] === scaleID) {\n      for (const prop of [axis + 'Min', axis + 'Max', axis + 'Value']) {\n        const raw = annotation[prop];\n        if (raw) {\n          const value = scale.parse(raw);\n          min = Math.min(min, value);\n          max = Math.max(max, value);\n        }\n      }\n    }\n  }\n  return {min, max};\n}\n\nexport { annotation as default };\n"]},"metadata":{},"sourceType":"module"}